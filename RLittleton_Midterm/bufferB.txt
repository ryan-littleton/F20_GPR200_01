//------------------------------------------------------------
// SIGNED DISTANCE FIELD FUNCTIONS
// Followed this tutorial on raymarching and SDF 
// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/
// Since sceneSDF is what creates the scene, it and functions dependent
// on it will be here and not in common

// sceneSDF: calculates a scene using sdf functions
//	  point: 			 input for the current point
float sceneSDF(vec3 point) {
    return sphereSDF(point);
}

// shortestDistanceToSurface: calcs shortest distance from eyePosition to surface
//	  eye: 			 input for the eye position
//	  rayDirection:  input for the ray direction
//	  start:  		 starting distance from the eye position
//	  end:  		 max distance to march
float shortestDistanceToSurface(vec3 eyePosition, vec3 rayDirection, float start, float end) {
    float depth = start;
    
    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
        
        float dist = sceneSDF(eyePosition + depth * rayDirection);
        
        if (dist < EPSILON) {
			return depth;
        }
        
        depth += dist;
        
        if (depth >= end) {
            return end;
        }
    }
    return end;
}

// estimateNormal: calculates an estimate normal from sdf
//	  p: 			 input for the current point along surface
vec3 estimateNormal(vec3 p) {
    return normalize(vec3(
        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),
        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),
        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // viewing plane (viewport) inputs
    const sBasis eyePosition = sBasis(0.0, 0.0, -5.0);
    const sScalar viewportHeight = 2.0, focalLength = 1.5;
    
    // viewport info
    sViewport vp;

    // ray
    sRay ray;
    
    // render
    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);
    initRayPersp(ray, eyePosition, vp.viewportPoint.xyz);
    
    // Light at normalized mouse xy
    vec2 mousePos = iMouse.xy / vp.resolution.xy;
    mousePos = mousePos * 2.0 - 1.0;
    pointLight light;
    initPointLight(light, vec3(mousePos, -10.0), vec4(1.0), 5.0);
    
    float dist = shortestDistanceToSurface(vp.viewportPoint.xyz, ray.direction.xyz, MIN_DIST, MAX_DIST);
    
    if (dist > MAX_DIST - EPSILON) {
        // Didn't hit anything
        fragColor = vec4(0.0, 0.0, 0.0, 0.0);
		return;
    }
    
    // Closest point on surface from eye position along ray direction
    vec3 p = eyePosition + dist * ray.direction.xyz;
    // Estimates normal from p
    vec3 normal = estimateNormal(p);

    //fragColor = vec4(1.0, 0.0, 0.0, 1.0);
    //fragColor = vec4(estimateNormal(p), 1.0);
    fragColor = calcLight(light, ray, normal, vec4(0.5,0.0,1.0,1.0), p);
}