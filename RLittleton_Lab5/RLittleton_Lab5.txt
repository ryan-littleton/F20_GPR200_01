/*
Author: Ryan Littleton - using starter from Daniel Buckstein
Class : GPR-200-01
Assignment : Lab 5
*/

// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN

//------------------------------------------------------------
// TYPE ALIASES & UTILITY FUNCTIONS

// sScalar: alias for a 1D scalar (non-vector)
#define sScalar float

// sCoord: alias for a 2D coordinate
#define sCoord vec2

// sDCoord: alias for a 2D displacement or measurement
#define sDCoord vec2

// sBasis: alias for a 3D basis vector
#define sBasis vec3

// sPoint: alias for a point/coordinate/location in space
#define sPoint vec4

// sVector: alias for a vector/displacement/change in space
#define sVector vec4


// color3: alias for a 3D vector representing RGB color
// 	(this is non-spatial so neither a point nor vector)
#define color3 vec3

// color4: alias for RGBA color, which is non-spatial
// 	(this is non-spatial so neither a point nor vector)
#define color4 vec4


// asPoint: promote a 3D vector into a 4D vector 
//	representing a point in space (w=1)
//    v: input 3D vector to be converted
sPoint asPoint(in sBasis v)
{
    return sPoint(v, 1.0);
}

// asVector: promote a 3D vector into a 4D vector 
//	representing a vector through space (w=0)
//    v: input 3D vector to be converted
sVector asVector(in sBasis v)
{
    return sVector(v, 0.0);
}


// lengthSq: calculate the squared length of a vector type
sScalar lengthSq(sDCoord x)
{
    return dot(x, x);
}
sScalar lengthSq(sBasis x)
{
    return dot(x, x);
}
sScalar lengthSq(sVector x)
{
    return dot(x, x);
}


//------------------------------------------------------------
// VIEWPORT INFO

// sViewport: info about viewport
//    viewportPoint: location on the viewing plane 
//							x = horizontal position
//							y = vertical position
//							z = plane depth (negative focal length)
//	  pixelCoord:    position of pixel in image
//							x = [0, width)	-> [left, right)
//							y = [0, height)	-> [bottom, top)
//	  resolution:    resolution of viewport
//							x = image width in pixels
//							y = image height in pixels
//    resolutionInv: resolution reciprocal
//							x = reciprocal of image width
//							y = reciprocal of image height
//	  size:       	 in-scene dimensions of viewport
//							x = viewport width in scene units
//							y = viewport height in scene units
//	  ndc: 			 normalized device coordinate
//							x = [-1, +1) -> [left, right)
//							y = [-1, +1) -> [bottom, top)
// 	  uv: 			 screen-space (UV) coordinate
//							x = [0, 1) -> [left, right)
//							y = [0, 1) -> [bottom, top)
//	  aspectRatio:   aspect ratio of viewport
//	  focalLength:   distance to viewing plane
struct sViewport
{
    sPoint viewportPoint;
	sCoord pixelCoord;
	sDCoord resolution;
	sDCoord resolutionInv;
	sDCoord size;
	sCoord ndc;
	sCoord uv;
	sScalar aspectRatio;
	sScalar focalLength;
};

// initViewport: calculate the viewing plane (viewport) coordinate
//    vp: 		      output viewport info structure
//    viewportHeight: input height of viewing plane
//    focalLength:    input distance between viewer and viewing plane
//    fragCoord:      input coordinate of current fragment (in pixels)
//    resolution:     input resolution of screen (in pixels)
void initViewport(out sViewport vp,
                  in sScalar viewportHeight, in sScalar focalLength,
                  in sCoord fragCoord, in sDCoord resolution)
{
    vp.pixelCoord = fragCoord;
    vp.resolution = resolution;
    vp.resolutionInv = 1.0 / vp.resolution;
    vp.aspectRatio = vp.resolution.x * vp.resolutionInv.y;
    vp.focalLength = focalLength;
    vp.uv = vp.pixelCoord * vp.resolutionInv;
    vp.ndc = vp.uv * 2.0 - 1.0;
    vp.size = sDCoord(vp.aspectRatio, 1.0) * viewportHeight;
    vp.viewportPoint = asPoint(sBasis(vp.ndc * vp.size * 0.5, -vp.focalLength));
}


//------------------------------------------------------------
// RAY INFO

// sRay: ray data structure
//	  origin: origin point in scene
//    direction: direction vector in scene
struct sRay
{
    sPoint origin;
    sVector direction;
};

// initRayPersp: initialize perspective ray
//    ray: 		   output ray
//    eyePosition: position of viewer in scene
//    viewport:    input viewing plane offset
void initRayPersp(out sRay ray,
             	  in sBasis eyePosition, in sBasis viewport)
{
    // ray origin relative to viewer is the origin
    // w = 1 because it represents a point; can ignore when using
    ray.origin = asPoint(eyePosition);

    // ray direction relative to origin is based on viewing plane coordinate
    // w = 0 because it represents a direction; can ignore when using
    ray.direction = asVector(viewport - eyePosition);
}

// initRayOrtho: initialize orthographic ray
//    ray: 		   output ray
//    eyePosition: position of viewer in scene
//    viewport:    input viewing plane offset
void initRayOrtho(out sRay ray,
             	  in sBasis eyePosition, in sBasis viewport)
{
    // offset eye position to point on plane at the same depth
    initRayPersp(ray, eyePosition + sBasis(viewport.xy, 0.0), viewport);
}


//------------------------------------------------------------
// RENDERING FUNCTIONS

// distort: creates a sin tunnel distortion effect
//	  origLoc:  2D coordinates
//	  fTime: time passed in for animation
sCoord distort(in sCoord origLoc, in float fTime)
{
    sCoord deformedLoc;
    deformedLoc = origLoc;
    
    // This is basically just experimentation, not really following any formula I know of
    float distortVal = sin(deformedLoc.y + fTime);
    deformedLoc.x = abs(deformedLoc.x - distortVal);
    return deformedLoc;
    
}// These rotation matrices from https://gist.github.com/onedayitwillmake/3288507
mat4 rotationX( in float angle ) {
	return mat4(	1.0,		0,			0,			0,
			 		0, 	cos(angle),	-sin(angle),		0,
					0, 	sin(angle),	 cos(angle),		0,
					0, 			0,			  0, 		1);
}

// These rotation matrices from https://gist.github.com/onedayitwillmake/3288507
mat4 rotationY( in float angle ) {
	return mat4(	cos(angle),		0,		sin(angle),	0,
			 				0,		1.0,			 0,	0,
					-sin(angle),	0,		cos(angle),	0,
							0, 		0,				0,	1);
}

// These rotation matrices from https://gist.github.com/onedayitwillmake/3288507
mat4 rotationZ( in float angle ) {
	return mat4(	cos(angle),		-sin(angle),	0,	0,
			 		sin(angle),		cos(angle),		0,	0,
							0,				0,		1,	0,
							0,				0,		0,	1);
}

// Lighting functions from my lab 4
// holds point light data
struct pointLight
{
    vec4 center;
    vec4 color;
    float intensity;
};
    
// inits the point light
void initPointLight(out pointLight light, in vec3 center, in vec4 color, in float intensity)
{
    light.center = asPoint(center);
    light.color = color;
    light.intensity = intensity;
}

// calcLight: calculates specular and diffuse for the light passed in
//	  light: 			 input for the current light
//	  surfaceColor: 	 input for color
//	  normal: 			 input for normal
//	  position: 		 input for position on sphere
//	  vView: 	 		 input for view vector
vec4 calcLight(in pointLight light, in color4 surfaceColor, in vec3 normal, in vec3 position, in vec3 vView)
{
    
    // Light direction to position
    vec3 vLightDir;
    vLightDir = light.center.xyz - position;
    vLightDir = normalize(vLightDir);
    
    // diffuse coefficient
    float fDiffuseCoef = max(0.0, dot(normal, vLightDir));
    float fDistanceToLight = distance(light.center.xyz, position);

    // attenuation
    float fAIntensity = 1.0/(1.0 + fDistanceToLight / light.intensity + (fDistanceToLight * fDistanceToLight) / (light.intensity * light.intensity));

    float fDiffuseIntensity = fDiffuseCoef * fAIntensity; // Final diffuse intensity
                
    vec3 vHalfway = normalize(vLightDir + vView); // Halfway vector
    float fSpecCoef = max(0.0, dot(normal, vHalfway)); // Spec coefficient Blinn-phong
    float fHiExp = 64.0; // Highlight exponent
    float fSpecIntensity = pow(fSpecCoef, fHiExp * 4.0); // Blinn-Phong
    vec3 specReflectColor = vec3(1.0);
    float ambientIntensity = 0.1;
    color3 ambientColor = color3(1.0);
    
    light.color.xyz; // Add the current light calc to the sum
    
    vec3 vReflectTotal = (fDiffuseIntensity * surfaceColor.xyz + fSpecIntensity * specReflectColor) *
                light.color.xyz;

        
    vec3 finalColor = ambientIntensity * ambientColor + vReflectTotal; // final color from ambient and lights
    return vec4(finalColor, 1.0); // to vec4 and return
}


// crossfade: fades between two textures based on time
//	  vp:  Viewport to calc resolution
//	  fTime: time passed in for animation
vec4 crossfade(in sViewport vp, in float fTime)
{
    // Calc loc for 1st texture
    sCoord px = vp.pixelCoord;
    sDCoord res = iChannelResolution[0].xy;
    sCoord loc1 = px / res;
    
    loc1 = distort(loc1, fTime); // Optional Distortion
    
    // Calc loc for 2nd texture
    sDCoord res2 = iChannelResolution[2].xy;
    sCoord loc2 = px / res2;
    
    loc2 = distort(loc2, fTime); // Optional Distortion
    
    float fSmoothTime = abs(sin(fTime) * 0.5 + 0.5); // Smoothly animating time
    return mix(texture(iChannel0, loc1), texture(iChannel2, loc2), fSmoothTime); // Crossfade between two textures
}

// cubemap: rotating cubemap
//	  ray:  needed for direction
//	  fTime: time passed in for rotation
vec4 cubemap(in sRay ray, in float fTime)
{
    vec4 cubeLoc = vec4(ray.direction.xyz, 1.0); // cubemap sample vector
    //cubeLoc.xy = distort(cubeLoc.xy, fTime); // Optional Distortion
    cubeLoc *= rotationY(fTime);
    
    return texture(iChannel1, cubeLoc.xyz);
}

// calcColor: calculate the color of current pixel
//	  vp:  input viewport info
//	  ray: input ray info
color4 calcColor(in sViewport vp, in sRay ray, in float fTime)
{
    
    //return crossfade(vp, fTime); // final crossfade
    
    //Lights
    pointLight light1;
    initPointLight(light1, ray.origin.xyz, vec4(1.0), 8.0);
    
    sCoord loc = vp.uv; // loc relative to display
    
    vec3 position = vec3(loc.xy, -5.0); // adding a z coord for the plane
    vec3 vView = normalize(ray.origin.xyz - ray.direction.xyz); // view vector
    
    vec3 normal = normalize(vec3(vp.viewportPoint.xy, 1.0)); // Bended normal
    vec4 surfaceCol = crossfade(vp, fTime); // Using the crossfade as color
    return calcLight(light1, surfaceCol, normal, position, vView); // Final Lights
    
    //return cubemap(ray, fTime); // cubemap rotating
    
}

//------------------------------------------------------------
// SHADERTOY MAIN

// mainImage: process the current pixel (exactly one call per pixel)
//    fragColor: output final color for current pixel
//    fragCoord: input location of current pixel in image (in pixels)
void mainImage(out color4 fragColor, in sCoord fragCoord)
{
    // viewing plane (viewport) inputs
    const sBasis eyePosition = sBasis(0.0);
    const sScalar viewportHeight = 2.0, focalLength = 1.5;
    
    // viewport info
    sViewport vp;

    // ray
    sRay ray;
    
    // render
    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);
    initRayPersp(ray, eyePosition, vp.viewportPoint.xyz);
    fragColor += calcColor(vp, ray, iTime);
}
